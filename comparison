#!/usr/bin/env python3

import sys
import re
import subprocess
import os

pattern = re.compile(r"(\d+\.\d+) \+- (\d+\.\d+) seconds time elapsed.+(\d+\.\d+)%")

# Stats collected from `perf` output
class Stats:
    def __init__(self, time_elapsed, time_elapsed_stderr, time_elapsed_pct_stderr):
        self.time_elapsed = time_elapsed
        self.time_elapsed_stderr = time_elapsed_stderr
        self.time_elapsed_pct_stderr = time_elapsed_pct_stderr

# Storage of a comparison between two stats
class StoredComparison:
    def __init__(self, test_case, stat_master, stat_branch):
        self.test_case = test_case
        self.stat_master = stat_master
        self.stat_branch = stat_branch    

# Thin abstraction for collecting + printing output stats at runtime.
# This exists because I plan on having a `CliReporter` (interactive)
# and a `TableReporter` (collects inputs and aggregates into a nice
# table).
class Reporter:
    def __init__(self, num_repeats):
        print(f"repeats = {num_repeats}")
        self.comparisons = []

    def on_comparison(self, test_case, stat_master, stat_branch):
        sc = StoredComparison(test_case, stat_master, stat_branch)
        self.comparisons.append(sc)

    def on_finish(self):
        names = [sc.test_case for sc in self.comparisons]
        master_elapseds = [sc.stat_master.time_elapsed for sc in self.comparisons]
        master_stderrs = [sc.stat_master.time_elapsed_stderr for sc in self.comparisons]
        branch_elapseds = [sc.stat_branch.time_elapsed for sc in self.comparisons]
        branch_stderrs = [sc.stat_branch.time_elapsed_stderr for sc in self.comparisons]
        speedups = list(map(lambda p: p[0]/p[1], zip(master_elapseds, branch_elapseds)))

        to_2dp_str = lambda f: "%.2f" % f
        master_strs = [to_2dp_str(v) for v in master_elapseds]
        master_stderrs_strs = [to_2dp_str(v) for v in master_stderrs]
        branch_strs = [to_2dp_str(v) for v in branch_elapseds]
        branch_stderrs_strs = [to_2dp_str(v) for v in branch_stderrs]
        speedup_strs = [to_2dp_str(v) for v in speedups]

        cols = [
            names,
            master_strs,
            master_stderrs_strs,
            branch_strs,
            branch_stderrs_strs,
            speedup_strs,
        ]
        col_widths = [max(map(len, col)) for col in cols]

        headers = [
            "Test Name",
            "master [secs]",
            "σ [secs]",
            "branch [secs]",
            "σ [secs]",
            "Speedup",
        ]

        # hack: fixup col widths for headers
        for i in range(0, len(col_widths)):
            col_widths[i] = max(col_widths[i], len(headers[i]))

        # print headers
        header_line = "|"
        for i in range(0, len(headers)):
            col_width = col_widths[i]
            header_line += ' '
            header_line += headers[i].rjust(col_width)
            header_line += ' |'
        print(header_line)

        # seperator
        separator_line = "|"
        for i in range(0, len(headers)):
            col_width = col_widths[i]
            separator_line += ' '
            separator_line += col_width * '-'
            separator_line += ' |'
        print(separator_line)

        # data rows
        for rownum in range(0, len(self.comparisons)):
            s = "|"
            for colnum in range(0, len(cols)):
                width = col_widths[colnum]
                data = cols[colnum][rownum]
                s += ' '
                s += data.rjust(width)
                s += ' |'
            print(s)

def get_stats(tc, *, install_bin_dir, repeats):
    env = os.environ.copy()
    env["PATH"] = f"{install_bin_dir}:{env['PATH']}"

    p = subprocess.run(["./run", "stat", tc],
                       env=env,
                       stdout=subprocess.PIPE,
                       stderr=subprocess.PIPE)

    if p.returncode != 0:
        print(p.stderr.decode(), file=sys.stdout)
        raise RuntimeError(f"{tc}: failed to run (master = {master})")

    for line in p.stdout.decode().splitlines():
        result = re.search(pattern, line)
        if result:
            return Stats(
                time_elapsed=float(result.group(1)),
                time_elapsed_stderr=float(result.group(2)),
                time_elapsed_pct_stderr=float(result.group(3)))
    raise RuntimeError("could not find stats in stdout")

def main():
    p = subprocess.run(["./run", "ls"], stdout=subprocess.PIPE)
    assert p.returncode == 0

    test_cases = p.stdout.decode().splitlines()
    repeats = 64
    reporter = Reporter(num_repeats=repeats)

    for test_case in test_cases:
        stats_master = get_stats(test_case,
                                 install_bin_dir=os.environ["OPENSIM_MASTER_INSTALL"],
                                 repeats=repeats)
        stats_branch = get_stats(test_case,
                                 install_bin_dir=os.environ["OPENSIM_BRANCH_INSTALL"],
                                 repeats=repeats)

        reporter.on_comparison(test_case, stats_master, stats_branch)
    reporter.on_finish()

if __name__ == '__main__':
    main()
